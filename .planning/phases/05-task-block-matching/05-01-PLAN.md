---
phase: 05-task-block-matching
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/Service/TaskBlockMatchingService.php
  - backend/src/Controller/PlanningController.php
autonomous: true

must_haves:
  truths:
    - "PlanningController /tasks endpoint returns timeBlocks for the day"
    - "Tasks in response include matchingBlock data when tags overlap with blocks"
    - "Tasks without matching tags have null matchingBlock"
  artifacts:
    - path: "backend/src/Service/TaskBlockMatchingService.php"
      provides: "Tag-based matching logic"
      exports: ["findMatchingBlocks", "findFirstAvailableBlock"]
    - path: "backend/src/Controller/PlanningController.php"
      provides: "Enhanced /tasks endpoint with timeBlocks and matchingBlock"
      contains: "timeBlocks"
  key_links:
    - from: "backend/src/Controller/PlanningController.php"
      to: "backend/src/Service/TimeBlockService.php"
      via: "Constructor injection"
      pattern: "TimeBlockService"
    - from: "backend/src/Controller/PlanningController.php"
      to: "backend/src/Service/TaskBlockMatchingService.php"
      via: "Constructor injection"
      pattern: "TaskBlockMatchingService"
---

<objective>
Create TaskBlockMatchingService with tag-based matching logic and enhance PlanningController to include timeBlocks and matching block info in the /tasks response.

Purpose: Enables frontend to know which blocks are active today and which block matches each task based on shared tags.

Output: Backend service and API changes that return matching block info for each task.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-task-block-matching/05-RESEARCH.md

# Existing patterns
@backend/src/Service/TimeBlockService.php
@backend/src/Controller/PlanningController.php
@backend/src/Facade/BrainDumpFacade.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TaskBlockMatchingService</name>
  <files>backend/src/Service/TaskBlockMatchingService.php</files>
  <action>
Create TaskBlockMatchingService following TimeBlockService pattern.

Two public methods:
1. `findMatchingBlocks(Task $task, array $activeBlocks): array`
   - Extract task tag IDs: `$task->getTags()->map(fn($t) => $t->getId())->toArray()`
   - Return empty array if task has no tags
   - Filter activeBlocks where at least one tag.id matches task tag IDs
   - Use `in_array($tag['id'], $taskTagIds, true)` for comparison

2. `findFirstAvailableBlock(Task $task, array $activeBlocks, \DateTimeInterface $currentTime): ?array`
   - Call findMatchingBlocks first
   - Sort matching blocks by startTime ascending
   - Return first block where endTime > currentTime (format 'H:i' for comparison)
   - Return null if no available matching block

Constructor can be empty (no dependencies needed, receives data as params).
  </action>
  <verify>`php bin/console lint:container` passes with no errors</verify>
  <done>TaskBlockMatchingService exists with both methods implemented</done>
</task>

<task type="auto">
  <name>Task 2: Enhance PlanningController /tasks endpoint</name>
  <files>backend/src/Controller/PlanningController.php</files>
  <action>
Modify getTasks() to include timeBlocks and per-task matching block info.

1. Add constructor dependencies:
   - `private readonly TimeBlockService $timeBlockService`
   - `private readonly TaskBlockMatchingService $taskBlockMatchingService`

2. In getTasks() method:
   - After loading tasks/events, get active blocks: `$activeBlocks = $this->timeBlockService->getActiveBlocksForDate($user, $today);`
   - Store current time: `$currentTime = new \DateTime();`

3. Modify task serialization (both unplannedTasks and conflictingTasksData):
   - For each task, call `$this->taskBlockMatchingService->findFirstAvailableBlock($task, $activeBlocks, $currentTime)`
   - Add to task data:
     ```php
     'matchingBlock' => $matchingBlock ? [
         'id' => $matchingBlock['id'],
         'name' => $matchingBlock['name'],
         'color' => $matchingBlock['color'],
     ] : null,
     ```

4. Add timeBlocks to response:
   ```php
   return $this->json([
       'tasks' => [...],
       'conflictingTasks' => [...],
       'events' => [...],
       'timeBlocks' => $activeBlocks,
   ]);
   ```

Note: Use Task entity's getTags() method which already works (see BrainDumpFacade serialization pattern).
  </action>
  <verify>
Start dev environment and test endpoint:
`curl -s http://localhost:8080/api/planning/tasks | jq '.timeBlocks'` returns array of blocks
`curl -s http://localhost:8080/api/planning/tasks | jq '.tasks[0].matchingBlock'` returns block or null
  </verify>
  <done>
/api/planning/tasks response includes timeBlocks array and each task has matchingBlock field (block object or null)
  </done>
</task>

</tasks>

<verification>
1. `php bin/console lint:container` - no service errors
2. API returns expected structure with timeBlocks and matchingBlock on tasks
3. Tasks with no tags have null matchingBlock
4. Tasks with tags matching a block show that block
</verification>

<success_criteria>
- TaskBlockMatchingService created with findMatchingBlocks and findFirstAvailableBlock methods
- PlanningController /tasks returns timeBlocks array in response
- Each task in response has matchingBlock field (null or {id, name, color})
- Tag intersection logic correctly identifies matching blocks
- First available (by time) block is selected when multiple match
</success_criteria>

<output>
After completion, create `.planning/phases/05-task-block-matching/05-01-SUMMARY.md`
</output>
