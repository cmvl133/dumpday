---
phase: 06
plan: 01
title: Fix Notes Panel Bugs
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/components/ui/dialog.tsx
  - frontend/src/components/notes/NotesExpandedModal.tsx
  - frontend/src/components/analysis/NotesList.tsx
autonomous: true

must_haves:
  truths:
    - "User clicks 'Add new note' in modal and a new empty note is created and selected for editing"
    - "Notes panel has exactly one close button (top right)"
    - "WYSIWYG editor shows formatted text while editing"
    - "Note preview in NotesList displays rendered HTML content"
  artifacts:
    - path: "frontend/src/components/ui/dialog.tsx"
      provides: "DialogContent variant without automatic close button"
    - path: "frontend/src/components/notes/NotesExpandedModal.tsx"
      provides: "Fixed add note flow and uses DialogContent without auto-close"
    - path: "frontend/src/components/analysis/NotesList.tsx"
      provides: "HTML rendering for note preview"
  key_links:
    - from: "NotesExpandedModal.tsx"
      to: "DialogContent"
      via: "hideCloseButton prop or variant"
      pattern: "DialogContent.*hideCloseButton|DialogContent.*variant"
---

<objective>
Fix all four bugs in the Notes panel functionality.

Purpose: Users need working notes management with proper WYSIWYG editing and clean UI.

Output: All NOTE-01 through NOTE-04 requirements satisfied.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@frontend/src/components/notes/NotesExpandedModal.tsx
@frontend/src/components/notes/TiptapEditor.tsx
@frontend/src/components/analysis/NotesList.tsx
@frontend/src/components/ui/dialog.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix duplicate close button (NOTE-02)</name>
  <files>
    frontend/src/components/ui/dialog.tsx
    frontend/src/components/notes/NotesExpandedModal.tsx
  </files>
  <action>
The DialogContent component in dialog.tsx (line 45-48) automatically renders a close button. NotesExpandedModal.tsx (line 257-259) also renders its own close button, causing duplicates.

Option A (preferred): Add a `hideCloseButton` prop to DialogContent:
1. In dialog.tsx, modify DialogContent to accept `hideCloseButton?: boolean` prop
2. Conditionally render the auto close button only when `hideCloseButton` is not true
3. In NotesExpandedModal.tsx, pass `hideCloseButton` to DialogContent

Option B: Remove the manual close button from NotesExpandedModal.tsx and rely on DialogContent's built-in one. However, the modal has a custom header layout that looks better with the button in the header, so Option A is preferred.

Implementation:
1. Update DialogContent interface to include `hideCloseButton?: boolean`
2. Wrap the DialogPrimitive.Close in a conditional `{!hideCloseButton && ...}`
3. In NotesExpandedModal.tsx line 160, add `hideCloseButton` prop to DialogContent
  </action>
  <verify>
    - Open the app and expand the Notes panel
    - Verify there is exactly ONE close button in the top right of the header
    - Click it and verify the modal closes
  </verify>
  <done>Notes expanded modal has single close button in custom header position</done>
</task>

<task type="auto">
  <name>Task 2: Fix "Add new note" button (NOTE-01)</name>
  <files>frontend/src/components/notes/NotesExpandedModal.tsx</files>
  <action>
The current `handleAddNote` function calls `onAdd('')` which creates a note with empty content, then tries to reload notes. The issue is the flow doesn't select the newly created note.

Fix the flow:
1. When user clicks "Add new note", call `onAdd('')` to create the note via API
2. After the note is created, the loadNotes() call fetches updated list
3. Problem: We need to auto-select the newly created note

Solution: Modify handleAddNote to:
1. Call onAdd('') - this dispatches createNote which adds to Redux store
2. After brief delay (allow API to return), reload notes from API
3. After reload, find the newest note (by createdAt) and select it
4. The new note will be selected and ready for editing in TiptapEditor

Update handleAddNote:
```typescript
const handleAddNote = async () => {
  if (onAdd) {
    onAdd('');
    // Wait for note creation then reload and select newest
    setTimeout(async () => {
      await loadNotes();
      // After reload, select the newest note (first in list if sorted by newest)
      if (sortOrder === 'newest') {
        // The newest note will be at index 0 after reload
        // Note: loadNotes updates the notes state, so we need to wait
        // Actually, loadNotes is async and updates notes state directly
        // We need to access the updated notes after loadNotes completes
      }
    }, 100);
  }
};
```

Better approach - track that we're adding a note:
1. Set a flag `isAddingNote = true`
2. Call onAdd('')
3. In loadNotes completion, if isAddingNote is true:
   - Select the first note (newest) from results
   - Set isAddingNote = false

Actually simplest fix: loadNotes already has access to `result` from API. Modify handleAddNote to pass a callback or use a ref to track pending selection.

Simplest implementation:
```typescript
const [pendingNewNote, setPendingNewNote] = useState(false);

const handleAddNote = () => {
  if (onAdd) {
    setPendingNewNote(true);
    onAdd('');
    setTimeout(loadNotes, 150);
  }
};

// In loadNotes, after setNotes(result):
if (pendingNewNote && result.length > 0 && sortOrder === 'newest') {
  setSelectedNote(result[0]);
  setEditContent(result[0].content);
  setPendingNewNote(false);
}
```
  </action>
  <verify>
    - Open Notes expanded modal
    - Click "Add new note" button
    - Verify a new empty note appears in the sidebar list
    - Verify the new note is automatically selected
    - Verify the TiptapEditor is ready to accept input
    - Type some text and click away - verify text is saved
  </verify>
  <done>Add new note creates a note and auto-selects it for immediate editing</done>
</task>

<task type="auto">
  <name>Task 3: Fix HTML preview in NotesList (NOTE-04)</name>
  <files>frontend/src/components/analysis/NotesList.tsx</files>
  <action>
In NotesList.tsx line 149, note content is rendered as plain text:
`<p className="text-sm flex-1">{note.content}</p>`

This doesn't render HTML tags - it shows them as raw text.

Fix by using dangerouslySetInnerHTML with proper sanitization (or use a lightweight HTML renderer).

Since notes content comes from the Tiptap editor which produces HTML, and the user controls their own notes, using dangerouslySetInnerHTML is acceptable here with basic class styling.

Replace line 149:
```tsx
<p className="text-sm flex-1">{note.content}</p>
```

With:
```tsx
<div
  className="text-sm flex-1 prose prose-sm dark:prose-invert max-w-none"
  dangerouslySetInnerHTML={{ __html: note.content }}
/>
```

The prose classes from Tailwind Typography will style the HTML content nicely (headings, lists, bold, italic, etc.).

Note: If @tailwindcss/typography is not installed, check tailwind.config and add if needed. Based on TiptapEditor.tsx using prose classes, it should already be available.
  </action>
  <verify>
    - Create a note with formatting (bold text, a list, a heading)
    - Close the expanded modal
    - View the note in the main NotesList section
    - Verify the preview shows formatted content (bold is bold, list has bullets)
    - NOT raw HTML tags like `<strong>`, `<ul>`, etc.
  </verify>
  <done>NotesList renders HTML content with proper formatting</done>
</task>

</tasks>

<verification>
After all tasks:

1. NOTE-01: Click "Add new note" in expanded modal -> note created and selected for editing
2. NOTE-02: Expanded modal has exactly one close button
3. NOTE-03: TiptapEditor in expanded modal shows formatted text (this should already work - verify)
4. NOTE-04: NotesList preview shows rendered HTML, not raw tags

Run `npm run lint` in frontend to check for errors.
</verification>

<success_criteria>
- All four NOTE requirements pass manual verification
- No duplicate UI elements
- No TypeScript/lint errors
- Notes workflow is smooth: create -> edit -> save -> preview shows formatted content
</success_criteria>

<output>
After completion, create `.planning/phases/06-notes-panel-fixes/06-01-SUMMARY.md`
</output>
