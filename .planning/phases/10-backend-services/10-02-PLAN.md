---
phase: 10-backend-services
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - backend/src/Service/TaskService.php
  - backend/src/Service/TaskUpdateResult.php
autonomous: true
user_setup: []

must_haves:
  truths:
    - "TaskService handles task CRUD without EntityManager in controllers"
    - "TaskService handles completion with recurring task generation"
    - "Task update returns result with optional generatedNextTask"
  artifacts:
    - path: "backend/src/Service/TaskService.php"
      provides: "Task CRUD, completion, tag management"
      exports: ["create", "update", "delete", "findByIdAndUser", "assignTags", "removeTag"]
      min_lines: 150
    - path: "backend/src/Service/TaskUpdateResult.php"
      provides: "Result object for task updates with side effects"
      exports: ["TaskUpdateResult"]
  key_links:
    - from: "TaskService.php"
      to: "RecurrenceService.php"
      via: "findNextOccurrenceDate"
      pattern: "recurrenceService->findNextOccurrenceDate"
    - from: "TaskService.php"
      to: "RecurringSyncService.php"
      via: "generateTask"
      pattern: "recurringSyncService->generateTask"
---

<objective>
Create TaskService that handles all task business logic.

Purpose: Extract CRUD, completion, and tag management from TaskController (320 lines) to enable thin controller pattern. Controllers will become HTTP-only wrappers.

Output: TaskService with all task operations, TaskUpdateResult for complex update responses.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/10-backend-services/10-RESEARCH.md
@.planning/phases/10-backend-services/10-01-SUMMARY.md
@backend/src/Controller/TaskController.php
@backend/src/DTO/Request/TaskCreateRequest.php
@backend/src/Service/RecurrenceService.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TaskUpdateResult DTO</name>
  <files>backend/src/Service/TaskUpdateResult.php</files>
  <action>
Create a simple result object for task updates that may produce side effects.

```php
<?php

declare(strict_types=1);

namespace App\Service;

use App\Entity\Task;

final readonly class TaskUpdateResult
{
    public function __construct(
        public Task $task,
        public ?Task $generatedNextTask = null,
    ) {
    }
}
```

This allows the update method to return both the updated task AND any generated recurring task.
  </action>
  <verify>
PHPStan: `docker compose exec php php -d memory_limit=512M vendor/bin/phpstan analyse src/Service/TaskUpdateResult.php --level=max`
  </verify>
  <done>
TaskUpdateResult exists as final readonly class with task and optional generatedNextTask.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create TaskService</name>
  <files>backend/src/Service/TaskService.php</files>
  <action>
Create TaskService that handles all task business logic.

Dependencies (constructor injection):
- EntityManagerInterface
- TaskRepository
- DailyNoteRepository
- TagRepository
- RecurrenceService (from 10-01)
- RecurringSyncService

Methods to implement:

1. `findByIdAndUser(int $id, User $user): ?Task`
   - Find task by ID, verify user ownership via DailyNote

2. `create(User $user, TaskCreateRequest $request): Task`
   - Get or create DailyNote for date
   - Create Task with title, category, dueDate
   - Persist and flush
   - Return task

3. `update(Task $task, array $data): TaskUpdateResult`
   - Use array_key_exists() for PATCH semantics (null vs missing)
   - Handle isCompleted with completion logic (lines 96-117 of TaskController)
   - Generate next recurring task on completion (use RecurrenceService + RecurringSyncService)
   - Handle all fields: title, dueDate, reminderTime, estimatedMinutes, fixedTime, canCombineWithEvents, needsFullFocus
   - Return TaskUpdateResult with task and optional generatedNextTask

4. `delete(Task $task): void`
   - Remove and flush

5. `assignTags(Task $task, User $user, array $tagIds): Task`
   - Clear existing tags
   - Add new tags (verify each tag belongs to user)
   - Flush and return task

6. `removeTag(Task $task, User $user, int $tagId): void`
   - Find tag, verify ownership, remove from task
   - Flush

Private helpers:
- `getOrCreateDailyNote(User $user, DateTimeInterface $date): DailyNote`
- `handleCompletion(Task $task, bool $isCompleted): ?Task` - returns generated next task
- `parseNullableDate(mixed $value): ?DateTime`
- `parseNullableDateTimeImmutable(mixed $value): ?DateTimeImmutable`

Reference the implementation in 10-RESEARCH.md lines 432-628.
  </action>
  <verify>
PHPStan: `docker compose exec php php -d memory_limit=512M vendor/bin/phpstan analyse src/Service/TaskService.php --level=max`
  </verify>
  <done>
TaskService exists with 6 public methods covering all task operations.
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. PHPStan passes: `docker compose exec php php -d memory_limit=512M vendor/bin/phpstan analyse src/Service/TaskService.php src/Service/TaskUpdateResult.php --level=max`
2. Services are properly registered (Symfony autowiring)
3. No compile errors in container: `docker compose exec php bin/console cache:clear`
</verification>

<success_criteria>
1. TaskUpdateResult exists as final readonly class
2. TaskService exists with all CRUD + tag methods
3. TaskService uses RecurrenceService for next occurrence finding
4. TaskService uses array_key_exists() for PATCH semantics
5. PHPStan passes for both files
</success_criteria>

<output>
After completion, create `.planning/phases/10-backend-services/10-02-SUMMARY.md`
</output>
