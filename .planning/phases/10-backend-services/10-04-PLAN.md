---
phase: 10-backend-services
plan: 04
type: execute
wave: 3
depends_on: ["10-02", "10-03"]
files_modified:
  - backend/src/Controller/TaskController.php
  - backend/src/Controller/PlanningController.php
autonomous: true
user_setup: []

must_haves:
  truths:
    - "TaskController under 100 lines"
    - "PlanningController under 80 lines"
    - "No EntityManager calls in controllers"
  artifacts:
    - path: "backend/src/Controller/TaskController.php"
      provides: "Thin HTTP wrapper for task operations"
      max_lines: 100
    - path: "backend/src/Controller/PlanningController.php"
      provides: "Thin HTTP wrapper for planning operations"
      max_lines: 80
  key_links:
    - from: "TaskController.php"
      to: "TaskService.php"
      via: "method calls"
      pattern: "taskService->"
    - from: "PlanningController.php"
      to: "PlanningService.php"
      via: "method calls"
      pattern: "planningService->"
---

<objective>
Refactor controllers to be thin HTTP wrappers using the new services.

Purpose: Controllers become HTTP-only (request parsing, authorization, response formatting). All business logic moves to services. This is the key requirement SVC-05.

Output: TaskController under 100 lines (from 320), PlanningController under 80 lines (from 257).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/10-backend-services/10-RESEARCH.md
@.planning/phases/10-backend-services/10-02-SUMMARY.md
@.planning/phases/10-backend-services/10-03-SUMMARY.md
@backend/src/Controller/TaskController.php
@backend/src/Controller/PlanningController.php
@backend/src/Service/TaskService.php
@backend/src/Service/PlanningService.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor TaskController to use TaskService</name>
  <files>backend/src/Controller/TaskController.php</files>
  <action>
Refactor TaskController to be a thin HTTP wrapper.

New dependencies (replace old ones):
- TaskService

Remove from constructor:
- TaskRepository (use TaskService::findByIdAndUser)
- DailyNoteRepository (TaskService handles)
- TagRepository (TaskService handles)
- EntityManagerInterface (TaskService handles)
- RecurringSyncService (TaskService handles)

Refactor each method:

1. `create()` - Keep MapRequestPayload, call TaskService::create, return TaskResponse
   ```php
   $task = $this->taskService->create($user, $request);
   return $this->json(TaskResponse::fromEntity($task), Response::HTTP_CREATED);
   ```

2. `update()` - Parse JSON, call TaskService::findByIdAndUser + update, format response
   ```php
   $task = $this->taskService->findByIdAndUser($id, $user);
   if ($task === null) { return 404; }
   $data = json_decode($request->getContent(), true);
   $result = $this->taskService->update($task, $data);
   // Format response with generatedNextTask if present
   ```

3. `delete()` - Call TaskService::findByIdAndUser + delete
   ```php
   $task = $this->taskService->findByIdAndUser($id, $user);
   if ($task === null) { return 404; }
   $this->taskService->delete($task);
   return $this->json(null, Response::HTTP_NO_CONTENT);
   ```

4. `assignTags()` - Parse JSON, call TaskService::assignTags, return tags
   ```php
   $task = $this->taskService->findByIdAndUser($id, $user);
   // ... validation
   $task = $this->taskService->assignTags($task, $user, $tagIds);
   // Format tag response
   ```

5. `removeTag()` - Call TaskService::findByIdAndUser + removeTag
   ```php
   $task = $this->taskService->findByIdAndUser($id, $user);
   $this->taskService->removeTag($task, $user, $tagId);
   ```

Remove private methods:
- findNextOccurrenceDate() - in RecurrenceService
- matchesRecurrencePattern() - in RecurrenceService

Target: Under 100 lines total.
  </action>
  <verify>
Line count: `wc -l backend/src/Controller/TaskController.php` should show < 100
PHPStan: `docker compose exec php php -d memory_limit=512M vendor/bin/phpstan analyse src/Controller/TaskController.php --level=max`
Grep: `grep -c "entityManager" backend/src/Controller/TaskController.php` should show 0
  </verify>
  <done>
TaskController under 100 lines, no EntityManager, uses TaskService.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor PlanningController to use PlanningService</name>
  <files>backend/src/Controller/PlanningController.php</files>
  <action>
Refactor PlanningController to be a thin HTTP wrapper.

New dependencies:
- PlanningService
- TaskService (for findByIdAndUser authorization)
- PlanningScheduleGenerator (keep for generateSchedule)

Remove from constructor:
- TaskRepository (use PlanningService)
- EventRepository (use PlanningService)
- EntityManagerInterface (PlanningService handles)
- TimeBlockService (PlanningService uses internally)
- TaskBlockMatchingService (PlanningService uses internally)
- TaskEventConflictResolver (PlanningService uses internally)

Refactor each method:

1. `getTasks()` - Call PlanningService::getTasksForPlanning, handle serialization
   ```php
   $data = $this->planningService->getTasksForPlanning($user, $today);
   // Serialize with planning-specific fields (hasConflict, matchingBlock, etc.)
   // Keep current serialization logic - it's planning-specific
   ```
   Note: The inline serialization in getTasks is intentional (planning-specific fields).
   Move the data fetching to service, keep serialization in controller.

2. `saveTaskPlanning()` - Call TaskService::findByIdAndUser + PlanningService::updatePlanningFields
   ```php
   $task = $this->taskService->findByIdAndUser($id, $user);
   if ($task === null) { return 404; }
   $data = json_decode($request->getContent(), true);
   $task = $this->planningService->updatePlanningFields($task, $data);
   // Format response
   ```

3. `generateSchedule()` - Keep using PlanningScheduleGenerator
   ```php
   // This method orchestrates AI schedule generation
   // Keep current implementation, just use TaskService for authorization
   ```

4. `acceptSchedule()` - Call PlanningService::acceptSchedule
   ```php
   $data = json_decode($request->getContent(), true);
   $this->planningService->acceptSchedule($user, $data['schedule'] ?? []);
   return $this->json(['success' => true]);
   ```

Target: Under 80 lines total.
  </action>
  <verify>
Line count: `wc -l backend/src/Controller/PlanningController.php` should show < 80
PHPStan: `docker compose exec php php -d memory_limit=512M vendor/bin/phpstan analyse src/Controller/PlanningController.php --level=max`
Grep: `grep -c "entityManager" backend/src/Controller/PlanningController.php` should show 0
  </verify>
  <done>
PlanningController under 80 lines, no EntityManager, uses services.
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. TaskController: `wc -l` < 100 lines
2. PlanningController: `wc -l` < 80 lines
3. No EntityManager in either: `grep -c "entityManager" backend/src/Controller/TaskController.php backend/src/Controller/PlanningController.php` shows 0 for both
4. PHPStan passes for both controllers
5. Manual test: Create task, update task, complete recurring task - all work
6. Manual test: Planning mode - view tasks, update planning fields, accept schedule - all work
</verification>

<success_criteria>
1. TaskController under 100 lines (from 320)
2. PlanningController under 80 lines (from 257)
3. No $this->entityManager->persist() or flush() in controllers
4. All existing functionality preserved (API responses unchanged)
5. PHPStan passes for both controllers
</success_criteria>

<output>
After completion, create `.planning/phases/10-backend-services/10-04-SUMMARY.md`
</output>
