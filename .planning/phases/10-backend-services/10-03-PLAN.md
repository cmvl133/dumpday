---
phase: 10-backend-services
plan: 03
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - backend/src/Service/PlanningService.php
autonomous: true
user_setup: []

must_haves:
  truths:
    - "PlanningService handles planning mode task operations"
    - "Schedule acceptance updates multiple tasks atomically"
    - "Planning task updates use PATCH semantics"
  artifacts:
    - path: "backend/src/Service/PlanningService.php"
      provides: "Planning mode operations: task queries, planning updates, schedule acceptance"
      exports: ["getTasksForPlanning", "updatePlanningFields", "acceptSchedule"]
      min_lines: 80
  key_links:
    - from: "PlanningService.php"
      to: "TaskRepository.php"
      via: "task queries"
      pattern: "taskRepository->find"
    - from: "PlanningService.php"
      to: "EntityManager"
      via: "flush"
      pattern: "entityManager->flush"
---

<objective>
Create PlanningService that handles planning mode operations.

Purpose: Extract planning-specific logic from PlanningController (257 lines) to enable thin controller pattern. The controller will handle HTTP concerns only.

Output: PlanningService with planning task queries, field updates, and schedule acceptance.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/10-backend-services/10-RESEARCH.md
@backend/src/Controller/PlanningController.php
@backend/src/Service/TimeBlockService.php
@backend/src/Service/TaskBlockMatchingService.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PlanningService</name>
  <files>backend/src/Service/PlanningService.php</files>
  <action>
Create PlanningService that handles planning mode business logic.

Dependencies (constructor injection):
- EntityManagerInterface
- TaskRepository
- EventRepository
- TimeBlockService
- TaskBlockMatchingService
- TaskEventConflictResolver

Methods to implement:

1. `getTasksForPlanning(User $user, DateTimeInterface $date): array`
   Returns structured data for planning mode:
   ```php
   [
       'unplannedTasks' => Task[],    // from findUnplannedTasksForToday
       'plannedTasks' => Task[],       // from findPlannedTasksForToday
       'events' => Event[],
       'activeBlocks' => array,        // from TimeBlockService
       'conflicts' => array,           // from TaskEventConflictResolver
   ]
   ```
   Note: This returns raw entities/data. The controller handles serialization with planning-specific fields (hasConflict, conflictingEvent, matchingBlock).

2. `updatePlanningFields(Task $task, array $data): Task`
   Update planning-specific fields using PATCH semantics (array_key_exists):
   - estimatedMinutes
   - fixedTime
   - canCombineWithEvents
   - needsFullFocus
   Flush and return task.

3. `acceptSchedule(User $user, array $scheduleItems): void`
   Process array of schedule items:
   ```php
   [
       ['taskId' => int, 'suggestedTime' => string, 'duration' => int, 'combinedWithEventId' => ?int],
       ...
   ]
   ```
   For each item:
   - Find task, verify ownership
   - Set fixedTime from suggestedTime
   - Update dueDate to today if overdue
   - Set estimatedMinutes from duration
   - Add combinedWithEventId to canCombineWithEvents array
   Flush once at end.

Reference PlanningController lines 117-169 for saveTaskPlanning, lines 214-256 for acceptSchedule.
  </action>
  <verify>
PHPStan: `docker compose exec php php -d memory_limit=512M vendor/bin/phpstan analyse src/Service/PlanningService.php --level=max`
  </verify>
  <done>
PlanningService exists with getTasksForPlanning, updatePlanningFields, and acceptSchedule methods.
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. PHPStan passes: `docker compose exec php php -d memory_limit=512M vendor/bin/phpstan analyse src/Service/PlanningService.php --level=max`
2. Service is properly registered (Symfony autowiring)
3. No compile errors: `docker compose exec php bin/console cache:clear`
</verification>

<success_criteria>
1. PlanningService exists with 3 public methods
2. getTasksForPlanning returns raw data (controller handles serialization)
3. updatePlanningFields uses PATCH semantics
4. acceptSchedule handles batch updates atomically
5. PHPStan passes
</success_criteria>

<output>
After completion, create `.planning/phases/10-backend-services/10-03-SUMMARY.md`
</output>
