---
phase: 09-backend-dtos
plan: 06
type: execute
wave: 3
depends_on: ["09-02", "09-03", "09-04"]
files_modified:
  - backend/src/Controller/TaskController.php
  - backend/src/Facade/BrainDumpFacade.php
  - backend/src/Controller/PlanningController.php
autonomous: true
user_setup: []

must_haves:
  truths:
    - "TaskController create() uses MapRequestPayload with TaskCreateRequest"
    - "BrainDumpFacade.serializeTask() method is removed"
    - "BrainDumpFacade uses TaskResponse for task serialization"
    - "PlanningController uses appropriate DTOs where beneficial"
    - "All validation happens via DTO constraints, not manual checks"
  artifacts:
    - path: "backend/src/Controller/TaskController.php"
      provides: "Task creation with validated Request DTO"
      contains: "MapRequestPayload"
    - path: "backend/src/Facade/BrainDumpFacade.php"
      provides: "Daily note data using Response DTOs"
      contains: "TaskResponse::fromEntity"
  key_links:
    - from: "TaskController::create"
      to: "TaskCreateRequest"
      via: "MapRequestPayload attribute"
    - from: "BrainDumpFacade"
      to: "TaskResponse"
      via: "fromEntity() in getDailyNoteData()"
---

<objective>
Integrate Request DTOs with MapRequestPayload and complete the Response DTO integration in BrainDumpFacade and PlanningController.

Purpose: Replace manual json_decode() and validation with Symfony's MapRequestPayload for automatic deserialization and validation. Complete the elimination of duplicate serialization in BrainDumpFacade.

Output: TaskController using Request DTOs, BrainDumpFacade using Response DTOs, PlanningController improved where beneficial.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-backend-dtos/09-RESEARCH.md

Depends on:
- Plan 02: TaskCreateRequest, TaskUpdateRequest
- Plan 03: TaskResponse
- Plan 04: DailyNoteResponse, ScheduleItemResponse

Files to update:
1. TaskController.php - use MapRequestPayload with TaskCreateRequest for create()
2. BrainDumpFacade.php - remove serializeTask(), use TaskResponse::fromEntity()
3. PlanningController.php - evaluate and update where DTOs add value

Note: TaskUpdateRequest integration is complex due to the "null vs missing field" distinction needed for PATCH. This plan will implement TaskCreateRequest integration but document the TaskUpdateRequest complexity for Phase 10 (Services) where we'll have better separation.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate TaskCreateRequest in TaskController</name>
  <files>
    backend/src/Controller/TaskController.php
  </files>
  <action>
Add imports:
```php
use App\DTO\Request\TaskCreateRequest;
use Symfony\Component\HttpKernel\Attribute\MapRequestPayload;
```

Update create() method signature and body:

```php
#[Route('', name: 'task_create', methods: ['POST'])]
public function create(
    #[CurrentUser] User $user,
    #[MapRequestPayload] TaskCreateRequest $request
): JsonResponse {
    // No manual json_decode needed - MapRequestPayload handles it
    // No manual validation needed - constraints are checked automatically

    $date = new \DateTime($request->date);
    $dailyNote = $this->dailyNoteRepository->findByUserAndDate($user, $date);

    if ($dailyNote === null) {
        $dailyNote = new DailyNote();
        $dailyNote->setUser($user);
        $dailyNote->setDate($date);
        $this->entityManager->persist($dailyNote);
    }

    $task = new Task();
    $task->setTitle($request->title);
    $task->setDailyNote($dailyNote);

    if ($request->category !== null && TaskCategory::tryFrom($request->category) !== null) {
        $task->setCategory(TaskCategory::from($request->category));
    }

    if ($request->dueDate !== null) {
        $task->setDueDate(new \DateTime($request->dueDate));
    }

    $this->entityManager->persist($task);
    $this->entityManager->flush();

    return $this->json(TaskResponse::fromEntity($task), Response::HTTP_CREATED);
}
```

IMPORTANT: MapRequestPayload returns 422 Unprocessable Entity with validation errors automatically when constraints fail. No manual validation code needed.

Note: Keep the existing manual validation in update() for now - the PATCH semantics with null/missing distinction are complex and better handled in Phase 10 when we extract to TaskService.
  </action>
  <verify>Run `docker compose exec php php -l backend/src/Controller/TaskController.php` for syntax check. Test validation by sending invalid data (empty title should return 422).</verify>
  <done>TaskController create() uses MapRequestPayload with TaskCreateRequest, removing ~10 lines of manual validation.</done>
</task>

<task type="auto">
  <name>Task 2: Update BrainDumpFacade to use Response DTOs</name>
  <files>
    backend/src/Facade/BrainDumpFacade.php
  </files>
  <action>
Add imports:
```php
use App\DTO\Response\TaskResponse;
use App\DTO\Response\EventResponse;
```

1. Remove the private `serializeTask()` method (lines 307-334)

2. Replace calls to `$this->serializeTask($task)` with `TaskResponse::fromEntity($task)`:
   - Line 202: `$tasks['overdue'][] = TaskResponse::fromEntity($task);`
   - Line 214: `$tasks['today'][] = TaskResponse::fromEntity($task);`
   - Line 257: `$tasks[$category][] = TaskResponse::fromEntity($task);`

3. For events serialization (lines 261-268), the current structure is simpler than EventResponse (no date field for inline usage). KEEP the simple inline format since it's different from the full EventResponse:
```php
// Keep as-is - this is a simplified format for DailyNote context
$events[] = [
    'id' => $event->getId(),
    'title' => $event->getTitle(),
    'startTime' => $event->getStartTime()?->format('H:i'),
    'endTime' => $event->getEndTime()?->format('H:i'),
    'date' => $event->getDate()?->format('Y-m-d'),
];
```

4. For notes (lines 271-277), keep simple format as it matches the API contract.

5. For journal (lines 279-284), keep simple format.

The key change is removing serializeTask() and using TaskResponse::fromEntity() - this eliminates the main duplication. The simpler event/note/journal serialization is intentionally different and can stay inline.
  </action>
  <verify>Run `docker compose exec php php -l backend/src/Facade/BrainDumpFacade.php` for syntax check. Run PHPStan: `docker compose exec php ./vendor/bin/phpstan analyse backend/src/Facade/BrainDumpFacade.php --level=6`</verify>
  <done>BrainDumpFacade.serializeTask() method removed, TaskResponse::fromEntity() used for task serialization.</done>
</task>

<task type="auto">
  <name>Task 3: Review and update PlanningController (selective)</name>
  <files>
    backend/src/Controller/PlanningController.php
  </files>
  <action>
Review PlanningController and update where DTOs add clear value.

The inline serialization in PlanningController (lines 58-80, 83-103) is planning-specific with fields like:
- hasConflict, conflictingEvent, matchingBlock

These are NOT standard TaskResponse fields - they're planning context. Creating a separate PlanningTaskResponse would be overkill for this single use case.

**Decision: Keep inline serialization in PlanningController.**

Rationale:
1. The planning responses include domain-specific fields (hasConflict, conflictingEvent, matchingBlock) that don't belong in the base TaskResponse
2. Creating PlanningTaskResponse adds complexity without significant benefit (only used in one place)
3. Phase 10 will extract PlanningService which is a better time to revisit this

**Only add import for potential future use:**
```php
use App\DTO\Response\TaskResponse;
use App\DTO\Response\EventResponse;
```

Do NOT change the actual serialization logic - it's appropriately different for the planning context.

If ScheduleItemResponse is useful, consider using it for the /planning/generate response (which returns array of schedule items). But the current generator service returns arrays, so wrapping in DTOs would add boilerplate without value until the service is refactored in Phase 10.
  </action>
  <verify>Run `docker compose exec php php -l backend/src/Controller/PlanningController.php` for syntax check (even if minimal changes). Document the decision in SUMMARY.md.</verify>
  <done>PlanningController reviewed - inline serialization kept intentionally due to planning-specific fields. DTOs imports added for future use.</done>
</task>

</tasks>

<verification>
Run PHPStan on all modified files:
```bash
docker compose exec php ./vendor/bin/phpstan analyse backend/src/Controller/TaskController.php backend/src/Facade/BrainDumpFacade.php backend/src/Controller/PlanningController.php --level=6
```

Check no serializeTask methods remain:
```bash
grep -rn "private function serializeTask" backend/src/
```
Should return empty (BrainDumpFacade and TaskSplitController methods removed in Plan 05 and this plan).

Verify MapRequestPayload is properly configured:
```bash
docker compose exec php php -r "
require 'backend/vendor/autoload.php';
\$reflection = new ReflectionMethod(App\Controller\TaskController::class, 'create');
foreach (\$reflection->getParameters() as \$param) {
    foreach (\$param->getAttributes() as \$attr) {
        echo \$attr->getName() . '\n';
    }
}
"
```
</verification>

<success_criteria>
1. TaskController create() uses MapRequestPayload with TaskCreateRequest
2. Manual validation removed from create() (handled by DTO constraints)
3. BrainDumpFacade.serializeTask() method removed
4. BrainDumpFacade uses TaskResponse::fromEntity() for task serialization
5. PlanningController reviewed with documented decision to keep inline serialization
6. PHPStan passes with no errors
7. No private serializeTask() methods remain in codebase
</success_criteria>

<output>
After completion, create `.planning/phases/09-backend-dtos/09-06-SUMMARY.md`
</output>
