---
phase: 09-backend-dtos
plan: 03
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - backend/src/DTO/Response/TaskResponse.php
  - backend/src/DTO/Response/TimeBlockResponse.php
autonomous: true
user_setup: []

must_haves:
  truths:
    - "TaskResponse::fromEntity() produces identical JSON to current inline serialization"
    - "TaskResponse includes nested TagResponse array"
    - "TimeBlockResponse::fromEntity() produces identical JSON to serializeTimeBlock()"
    - "TimeBlockResponse includes nested TagResponse array"
  artifacts:
    - path: "backend/src/DTO/Response/TaskResponse.php"
      provides: "Task serialization with tags"
      exports: ["TaskResponse"]
    - path: "backend/src/DTO/Response/TimeBlockResponse.php"
      provides: "TimeBlock serialization with tags"
      exports: ["TimeBlockResponse"]
  key_links:
    - from: "TaskResponse"
      to: "TagResponse"
      via: "array_map in fromEntity()"
    - from: "TimeBlockResponse"
      to: "TagResponse"
      via: "array_map in fromEntity()"
---

<objective>
Create TaskResponse and TimeBlockResponse DTOs that depend on TagResponse for nested tag serialization.

Purpose: These DTOs eliminate the most significant serialization duplication - TaskResponse replaces 6+ identical inline arrays across TaskController, TaskSplitController, and BrainDumpFacade.

Output: Two readonly DTO classes that use TagResponse for nested serialization.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-backend-dtos/09-RESEARCH.md

Depends on Plan 01: TagResponse must exist.

Current serializeTask() patterns to consolidate:

1. TaskController create (lines 73-93) - missing isDropped!
2. TaskController update (lines 182-206) - full version with tags
3. TaskSplitController serializeTask (lines 196-222) - full version
4. BrainDumpFacade serializeTask (lines 310-333) - missing isDropped!

CRITICAL: Note the inconsistency - some serializations include isDropped, some don't. The DTO should include ALL fields for consistency. The API contract should be complete.

TimeBlockController serializeTimeBlock (lines 376-393):
- id, name, color, startTime, endTime, recurrenceType, recurrenceDays, isActive, createdAt, tags
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TaskResponse DTO</name>
  <files>
    backend/src/DTO/Response/TaskResponse.php
  </files>
  <action>
Create TaskResponse DTO with ALL fields from the most complete serialization (TaskController update, TaskSplitController).

Use TagResponse for nested tags serialization.

```php
namespace App\DTO\Response;

use App\Entity\Task;

final readonly class TaskResponse
{
    /**
     * @param TagResponse[] $tags
     */
    public function __construct(
        public int $id,
        public string $title,
        public bool $isCompleted,
        public bool $isDropped,
        public ?string $dueDate,
        public string $category,
        public ?string $completedAt,
        public ?string $reminderTime,
        public ?int $estimatedMinutes,
        public ?string $fixedTime,
        public ?array $canCombineWithEvents,
        public bool $needsFullFocus,
        public ?int $recurringTaskId,
        public ?int $parentTaskId,
        public bool $isPart,
        public ?int $partNumber,
        public ?string $progress,
        public bool $hasSubtasks,
        public array $tags,
    ) {
    }

    public static function fromEntity(Task $task): self
    {
        return new self(
            id: $task->getId(),
            title: $task->getTitle(),
            isCompleted: $task->isCompleted(),
            isDropped: $task->isDropped(),
            dueDate: $task->getDueDate()?->format('Y-m-d'),
            category: $task->getCategory()->value,
            completedAt: $task->getCompletedAt()?->format('c'),
            reminderTime: $task->getReminderTime()?->format('H:i'),
            estimatedMinutes: $task->getEstimatedMinutes(),
            fixedTime: $task->getFixedTime()?->format('H:i'),
            canCombineWithEvents: $task->getCanCombineWithEvents(),
            needsFullFocus: $task->isNeedsFullFocus(),
            recurringTaskId: $task->getRecurringTask()?->getId(),
            parentTaskId: $task->getParentTask()?->getId(),
            isPart: $task->isPart(),
            partNumber: $task->getPartNumber(),
            progress: $task->getProgress(),
            hasSubtasks: $task->hasSubtasks(),
            tags: array_map(
                fn($tag) => TagResponse::fromEntity($tag),
                $task->getTags()->toArray()
            ),
        );
    }
}
```

IMPORTANT: Field order and names must match existing API responses exactly to maintain backward compatibility with frontend.
  </action>
  <verify>File exists with correct structure. Run `docker compose exec php php -l backend/src/DTO/Response/TaskResponse.php` for syntax check.</verify>
  <done>TaskResponse DTO exists with all 18 fields including nested TagResponse[] for tags.</done>
</task>

<task type="auto">
  <name>Task 2: Create TimeBlockResponse DTO</name>
  <files>
    backend/src/DTO/Response/TimeBlockResponse.php
  </files>
  <action>
Create TimeBlockResponse DTO matching TimeBlockController.serializeTimeBlock():

```php
namespace App\DTO\Response;

use App\Entity\TimeBlock;

final readonly class TimeBlockResponse
{
    /**
     * @param TagResponse[] $tags
     */
    public function __construct(
        public int $id,
        public string $name,
        public string $color,
        public ?string $startTime,
        public ?string $endTime,
        public string $recurrenceType,
        public ?array $recurrenceDays,
        public bool $isActive,
        public ?string $createdAt,
        public array $tags,
    ) {
    }

    public static function fromEntity(TimeBlock $timeBlock): self
    {
        return new self(
            id: $timeBlock->getId(),
            name: $timeBlock->getName(),
            color: $timeBlock->getColor(),
            startTime: $timeBlock->getStartTime()?->format('H:i'),
            endTime: $timeBlock->getEndTime()?->format('H:i'),
            recurrenceType: $timeBlock->getRecurrenceType()->value,
            recurrenceDays: $timeBlock->getRecurrenceDays(),
            isActive: $timeBlock->isActive(),
            createdAt: $timeBlock->getCreatedAt()?->format('c'),
            tags: array_map(
                fn($tag) => TagResponse::fromEntity($tag),
                $timeBlock->getTags()->toArray()
            ),
        );
    }
}
```

Note: recurrenceType uses ->value to get string from enum (same as existing code).
  </action>
  <verify>File exists with correct structure. Run `docker compose exec php php -l backend/src/DTO/Response/TimeBlockResponse.php` for syntax check.</verify>
  <done>TimeBlockResponse DTO exists with all fields including nested TagResponse[] for tags.</done>
</task>

</tasks>

<verification>
Run PHPStan to verify type safety including the dependency on TagResponse:
```bash
docker compose exec php ./vendor/bin/phpstan analyse backend/src/DTO/Response --level=6
```

Verify imports work correctly:
```bash
docker compose exec php php -r "
require 'backend/vendor/autoload.php';
\$reflection = new ReflectionClass(App\DTO\Response\TaskResponse::class);
echo 'TaskResponse has ' . count(\$reflection->getConstructor()->getParameters()) . ' parameters\n';
"
```
</verification>

<success_criteria>
1. TaskResponse created with all 18 fields matching existing serialization
2. TimeBlockResponse created with all fields matching serializeTimeBlock()
3. Both DTOs use TagResponse for nested tag serialization
4. Field names and types match existing API responses exactly
5. PHPStan passes with no errors
6. Both DTOs use PHP 8.2+ readonly class syntax with fromEntity() factories
</success_criteria>

<output>
After completion, create `.planning/phases/09-backend-dtos/09-03-SUMMARY.md`
</output>
