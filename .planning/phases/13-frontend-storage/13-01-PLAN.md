---
phase: 13-frontend-storage
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/lib/storage.ts
  - frontend/src/hooks/useStorage.ts
autonomous: true

must_haves:
  truths:
    - "Storage keys are defined in a single location"
    - "TypeScript catches invalid storage key usage at compile time"
    - "Non-hook code can read/write storage with type safety"
    - "React components can use storage with useState-like API"
  artifacts:
    - path: "frontend/src/lib/storage.ts"
      provides: "Storage key constants and typed utility functions"
      exports: ["STORAGE_KEYS", "StorageSchema", "getStorageItem", "setStorageItem", "removeStorageItem"]
    - path: "frontend/src/hooks/useStorage.ts"
      provides: "React hook for typed localStorage access"
      exports: ["useStorage"]
  key_links:
    - from: "frontend/src/hooks/useStorage.ts"
      to: "frontend/src/lib/storage.ts"
      via: "imports StorageKey, StorageSchema"
      pattern: "import.*from.*storage"
---

<objective>
Create typed storage infrastructure for centralized localStorage access.

Purpose: Eliminate scattered localStorage calls with duplicate try/catch patterns and string literal keys. Provide compile-time safety for storage key usage.

Output: Storage constants file with typed utilities and useStorage React hook.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-frontend-storage/13-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create storage constants and utility functions</name>
  <files>frontend/src/lib/storage.ts</files>
  <action>
Create `frontend/src/lib/storage.ts` with:

1. Storage key constants (using `as const` for type narrowing):
```typescript
export const STORAGE_KEYS = {
  LAST_MODAL: 'dopaminder_last_modal',
  TAG_FILTER: 'tagFilter',  // Keep existing key for backward compatibility
  SENT_REMINDERS: 'dopaminder_sent_reminders',
  SESSION_START: 'dopaminder_session_start',
  COLLAPSED_BOXES: 'dopaminder_collapsed_boxes',
} as const;
```

2. Type definitions:
```typescript
export type StorageKey = typeof STORAGE_KEYS[keyof typeof STORAGE_KEYS];

// BoxId type for collapsed boxes (from AnalysisResults.tsx)
type BoxId = 'scheduled' | 'someday' | 'notes' | 'journal';

export interface StorageSchema {
  [STORAGE_KEYS.LAST_MODAL]: string | null;
  [STORAGE_KEYS.TAG_FILTER]: { activeFilters: number[]; filterMode: 'and' | 'or' };
  [STORAGE_KEYS.SENT_REMINDERS]: Record<string, number>;
  [STORAGE_KEYS.SESSION_START]: string;
  [STORAGE_KEYS.COLLAPSED_BOXES]: BoxId[];
}
```

3. Non-hook utility functions for Redux slices:
```typescript
export function getStorageItem<K extends StorageKey>(
  key: K,
  fallback: StorageSchema[K]
): StorageSchema[K] {
  try {
    const item = localStorage.getItem(key);
    return item ? JSON.parse(item) : fallback;
  } catch {
    return fallback;
  }
}

export function setStorageItem<K extends StorageKey>(
  key: K,
  value: StorageSchema[K]
): void {
  try {
    localStorage.setItem(key, JSON.stringify(value));
  } catch {
    // Silently fail - storage might be full or disabled
  }
}

export function removeStorageItem<K extends StorageKey>(key: K): void {
  try {
    localStorage.removeItem(key);
  } catch {
    // Silently fail
  }
}
```

Key decisions:
- Keep `tagFilter` key name (not `dopaminder_tag_filter`) for backward compatibility with existing user data
- Export BoxId type so AnalysisResults.tsx can import it
- All utilities have try/catch for error handling
  </action>
  <verify>
TypeScript compilation: `cd frontend && npx tsc --noEmit`
File exists and exports correct symbols.
  </verify>
  <done>
- STORAGE_KEYS constant exported with all 5 keys
- StorageSchema interface maps each key to its value type
- getStorageItem, setStorageItem, removeStorageItem functions exported
- All functions have proper TypeScript generics for type inference
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useStorage React hook</name>
  <files>frontend/src/hooks/useStorage.ts</files>
  <action>
Create `frontend/src/hooks/useStorage.ts` with:

```typescript
import { useState, useCallback } from 'react';
import type { StorageKey, StorageSchema } from '@/lib/storage';

/**
 * React hook for typed localStorage access.
 * Provides useState-like API with automatic persistence.
 *
 * @param key - Storage key from STORAGE_KEYS
 * @param initialValue - Default value if nothing stored
 * @returns [value, setValue, removeValue] tuple
 */
export function useStorage<K extends StorageKey>(
  key: K,
  initialValue: StorageSchema[K]
): [StorageSchema[K], (value: StorageSchema[K]) => void, () => void] {
  // Initialize from localStorage or fallback to initial
  const [storedValue, setStoredValue] = useState<StorageSchema[K]>(() => {
    try {
      const item = localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch {
      return initialValue;
    }
  });

  // Setter that persists to localStorage
  const setValue = useCallback((value: StorageSchema[K]) => {
    try {
      setStoredValue(value);
      localStorage.setItem(key, JSON.stringify(value));
    } catch {
      // Silently fail - storage might be full or disabled
    }
  }, [key]);

  // Remove from localStorage
  const removeValue = useCallback(() => {
    try {
      setStoredValue(initialValue);
      localStorage.removeItem(key);
    } catch {
      // Silently fail
    }
  }, [key, initialValue]);

  return [storedValue, setValue, removeValue];
}
```

Key decisions:
- useState with lazy initializer reads from storage only on mount
- useCallback for stable function references
- Return tuple matches useState pattern for familiarity
- Third element (removeValue) resets to initialValue AND removes from storage
  </action>
  <verify>
TypeScript compilation: `cd frontend && npx tsc --noEmit`
Hook follows React rules (no conditional hooks, uses useCallback).
  </verify>
  <done>
- useStorage hook exported
- Hook accepts key from STORAGE_KEYS and initialValue
- Returns [value, setValue, removeValue] tuple
- TypeScript infers correct value type from key
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. TypeScript compilation passes: `cd frontend && npx tsc --noEmit`
2. Storage module exports all expected symbols:
   - STORAGE_KEYS (5 keys)
   - StorageSchema type
   - getStorageItem, setStorageItem, removeStorageItem functions
3. useStorage hook exports correctly
4. Type inference works: `getStorageItem(STORAGE_KEYS.TAG_FILTER, ...)` returns `{ activeFilters: number[], filterMode: 'and' | 'or' }`
</verification>

<success_criteria>
- [ ] `frontend/src/lib/storage.ts` exists with all exports
- [ ] `frontend/src/hooks/useStorage.ts` exists with useStorage hook
- [ ] TypeScript compilation passes with no errors
- [ ] Storage keys match existing keys in codebase (backward compatible)
</success_criteria>

<output>
After completion, create `.planning/phases/13-frontend-storage/13-01-SUMMARY.md`
</output>
