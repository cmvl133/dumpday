---
phase: 13-frontend-storage
plan: 03
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - frontend/src/hooks/useReminders.ts
  - frontend/src/hooks/useAutoModal.ts
  - frontend/src/components/analysis/AnalysisResults.tsx
autonomous: false

must_haves:
  truths:
    - "useReminders uses centralized storage utilities"
    - "useAutoModal uses centralized storage utilities"
    - "AnalysisResults uses useStorage hook"
    - "No direct localStorage calls outside lib/storage.ts"
    - "All existing functionality preserved (reminders, auto-modal, collapsed boxes)"
  artifacts:
    - path: "frontend/src/hooks/useReminders.ts"
      provides: "Reminder notifications with centralized storage"
      contains: "STORAGE_KEYS.SENT_REMINDERS"
    - path: "frontend/src/hooks/useAutoModal.ts"
      provides: "Auto-modal timing with centralized storage"
      contains: "STORAGE_KEYS.SESSION_START"
    - path: "frontend/src/components/analysis/AnalysisResults.tsx"
      provides: "Collapsible boxes with useStorage hook"
      contains: "useStorage"
  key_links:
    - from: "frontend/src/hooks/useReminders.ts"
      to: "frontend/src/lib/storage.ts"
      via: "imports getStorageItem, setStorageItem, STORAGE_KEYS"
      pattern: "import.*STORAGE_KEYS.*from.*storage"
    - from: "frontend/src/components/analysis/AnalysisResults.tsx"
      to: "frontend/src/hooks/useStorage.ts"
      via: "imports useStorage"
      pattern: "import.*useStorage.*from.*hooks"
---

<objective>
Migrate hooks and components to use centralized storage utilities.

Purpose: Complete the storage migration by updating useReminders, useAutoModal, and AnalysisResults. These are the remaining files with direct localStorage access.

Output: All localStorage access goes through centralized storage module. No direct localStorage calls anywhere except lib/storage.ts.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-frontend-storage/13-01-SUMMARY.md
@frontend/src/hooks/useReminders.ts
@frontend/src/hooks/useAutoModal.ts
@frontend/src/components/analysis/AnalysisResults.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate useReminders.ts and useAutoModal.ts</name>
  <files>frontend/src/hooks/useReminders.ts, frontend/src/hooks/useAutoModal.ts</files>
  <action>
**useReminders.ts:**

1. Add import at top:
```typescript
import { getStorageItem, setStorageItem, STORAGE_KEYS } from '@/lib/storage';
```

2. Remove local key constant:
```typescript
// DELETE:
const SENT_REMINDERS_KEY = 'dopaminder_sent_reminders';
```

3. Refactor `getSentReminders`:
```typescript
// OLD function has cleanup logic for entries older than 24h
// Keep the cleanup logic but use centralized storage

function getSentReminders(): Set<string> {
  const data = getStorageItem(STORAGE_KEYS.SENT_REMINDERS, {});
  // Clean up old entries (older than 24 hours)
  const now = Date.now();
  const filtered = Object.entries(data).filter(
    ([, timestamp]) => now - (timestamp as number) < 24 * 60 * 60 * 1000
  );
  return new Set(filtered.map(([key]) => key));
}
```

4. Refactor `markReminderSent`:
```typescript
function markReminderSent(taskId: number, reminderTime: string): void {
  const data = getStorageItem(STORAGE_KEYS.SENT_REMINDERS, {});
  const key = `${taskId}-${reminderTime}`;
  data[key] = Date.now();
  setStorageItem(STORAGE_KEYS.SENT_REMINDERS, data);
}
```

**useAutoModal.ts:**

1. Add import at top:
```typescript
import { getStorageItem, setStorageItem, STORAGE_KEYS } from '@/lib/storage';
```

2. Remove local key constant:
```typescript
// DELETE:
const SESSION_START_KEY = 'dopaminder_session_start';
```

3. Refactor `getSessionStart`:
```typescript
function getSessionStart(): number {
  const stored = getStorageItem(STORAGE_KEYS.SESSION_START, '');
  if (stored) {
    const parsed = parseInt(stored, 10);
    // Check if session start is from today
    const today = new Date().toDateString();
    const storedDate = new Date(parsed).toDateString();
    if (today === storedDate) {
      return parsed;
    }
  }
  // New day or no stored value - set new session start
  const now = Date.now();
  setStorageItem(STORAGE_KEYS.SESSION_START, String(now));
  return now;
}
```

Key decisions:
- Keep business logic (24h cleanup, same-day check) intact
- Only change storage access to use centralized utilities
  </action>
  <verify>
TypeScript compilation: `cd frontend && npx tsc --noEmit`
Grep for direct localStorage calls:
- `grep -n "localStorage" frontend/src/hooks/useReminders.ts` (should return nothing)
- `grep -n "localStorage" frontend/src/hooks/useAutoModal.ts` (should return nothing)
  </verify>
  <done>
- useReminders imports from @/lib/storage
- useAutoModal imports from @/lib/storage
- No direct localStorage calls in either hook
- Reminder cleanup logic (24h expiry) preserved
- Session start same-day check preserved
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate AnalysisResults.tsx</name>
  <files>frontend/src/components/analysis/AnalysisResults.tsx</files>
  <action>
Refactor `frontend/src/components/analysis/AnalysisResults.tsx`:

1. Add imports at top:
```typescript
import { useStorage } from '@/hooks/useStorage';
import { STORAGE_KEYS } from '@/lib/storage';
```

2. Remove local helpers and key constant:
```typescript
// DELETE these:
const COLLAPSED_BOXES_KEY = 'dopaminder_collapsed_boxes';
type BoxId = 'scheduled' | 'someday' | 'notes' | 'journal';  // Keep if not exported from storage.ts
function getCollapsedBoxes(): BoxId[] { ... }
function saveCollapsedBoxes(boxes: BoxId[]): void { ... }
```

Note: BoxId type should be imported from @/lib/storage if it's exported there.

3. In the component, replace useState + useEffect pattern:
```typescript
// OLD:
const [collapsedBoxes, setCollapsedBoxes] = useState<BoxId[]>([]);
useEffect(() => {
  setCollapsedBoxes(getCollapsedBoxes());
}, []);

// NEW:
const [collapsedBoxes, setCollapsedBoxes] = useStorage(STORAGE_KEYS.COLLAPSED_BOXES, []);
```

4. Simplify toggleBox:
```typescript
// OLD:
const toggleBox = (boxId: BoxId) => {
  setCollapsedBoxes((prev) => {
    const newBoxes = prev.includes(boxId)
      ? prev.filter((id) => id !== boxId)
      : [...prev, boxId];
    saveCollapsedBoxes(newBoxes);  // Manual save
    return newBoxes;
  });
};

// NEW:
const toggleBox = (boxId: BoxId) => {
  const newBoxes = collapsedBoxes.includes(boxId)
    ? collapsedBoxes.filter((id) => id !== boxId)
    : [...collapsedBoxes, boxId];
  setCollapsedBoxes(newBoxes);  // useStorage handles persistence
};
```

Note: toggleBox changes from callback pattern to direct because useStorage's setter already persists.

5. Keep BoxId type definition if not importing from storage.ts:
```typescript
type BoxId = 'scheduled' | 'someday' | 'notes' | 'journal';
```

Key decisions:
- Use useStorage hook since this is a React component
- No useEffect needed - useStorage initializes from storage on mount
- setCollapsedBoxes from useStorage auto-persists, no manual save needed
  </action>
  <verify>
TypeScript compilation: `cd frontend && npx tsc --noEmit`
Grep for direct localStorage calls:
- `grep -n "localStorage" frontend/src/components/analysis/AnalysisResults.tsx` (should return nothing)
  </verify>
  <done>
- AnalysisResults imports useStorage from @/hooks/useStorage
- AnalysisResults imports STORAGE_KEYS from @/lib/storage
- No direct localStorage calls
- No useEffect for loading collapsed state
- toggleBox uses useStorage setter (auto-persists)
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete storage centralization across all files</what-built>
  <how-to-verify>
1. Start frontend: `cd frontend && npm run dev`
2. Open http://localhost:3000

**Test tag filter persistence:**
- Click on tag filter chips to activate filters
- Refresh the page
- Filters should still be active

**Test collapsed boxes persistence:**
- Collapse "This Week" or "Later" sections
- Refresh the page
- Sections should still be collapsed

**Test auto-modal timing (if enabled in settings):**
- Note current time
- Wait for check-in interval or verify session start is tracked in localStorage

**Verify no direct localStorage calls:**
Run: `grep -rn "localStorage\." frontend/src --include="*.ts" --include="*.tsx" | grep -v "lib/storage.ts"`
Should return empty (only lib/storage.ts accesses localStorage directly)
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
After completing all tasks:

1. TypeScript compilation passes: `cd frontend && npx tsc --noEmit`

2. No direct localStorage calls outside storage module:
```bash
grep -rn "localStorage\." frontend/src --include="*.ts" --include="*.tsx" | grep -v "lib/storage.ts"
```
Should return empty

3. All storage keys defined in one place:
```bash
grep -n "STORAGE_KEYS" frontend/src/lib/storage.ts
```
Should show all 5 keys

4. Manual testing confirms persistence works for all features
</verification>

<success_criteria>
- [ ] useReminders.ts uses getStorageItem/setStorageItem from @/lib/storage
- [ ] useAutoModal.ts uses getStorageItem/setStorageItem from @/lib/storage
- [ ] AnalysisResults.tsx uses useStorage hook from @/hooks/useStorage
- [ ] No direct localStorage calls outside lib/storage.ts
- [ ] TypeScript compilation passes
- [ ] All storage-dependent features work correctly (manual verification)
</success_criteria>

<output>
After completion, create `.planning/phases/13-frontend-storage/13-03-SUMMARY.md`
</output>
