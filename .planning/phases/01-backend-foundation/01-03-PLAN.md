---
phase: 01-backend-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - backend/src/Service/TimeBlockService.php
  - backend/src/Controller/TimeBlockController.php
  - backend/src/Facade/BrainDumpFacade.php
autonomous: true

must_haves:
  truths:
    - "GET /api/time-block/date/{date} returns active blocks for specific date"
    - "TimeBlockService correctly filters blocks by recurrence pattern for given date"
    - "DailyNote response includes timeBlocks array"
    - "Daily recurrence blocks appear every day"
    - "Weekdays recurrence blocks appear Monday-Friday only"
    - "Custom recurrence blocks appear only on specified days"
  artifacts:
    - path: "backend/src/Service/TimeBlockService.php"
      provides: "Service to compute active blocks for a date"
      exports: ["TimeBlockService", "getActiveBlocksForDate", "isActiveOnDate"]
      min_lines: 50
    - path: "backend/src/Controller/TimeBlockController.php"
      provides: "Date-specific endpoint"
      contains: "getForDate"
    - path: "backend/src/Facade/BrainDumpFacade.php"
      provides: "TimeBlocks in DailyNote response"
      contains: "timeBlocks"
  key_links:
    - from: "backend/src/Controller/TimeBlockController.php"
      to: "backend/src/Service/TimeBlockService.php"
      via: "dependency injection"
      pattern: "TimeBlockService"
    - from: "backend/src/Facade/BrainDumpFacade.php"
      to: "backend/src/Service/TimeBlockService.php"
      via: "service call"
      pattern: "timeBlockService->getActiveBlocksForDate"
---

<objective>
Create TimeBlockService for date-based block computation and integrate into API

Purpose: Enable frontend to fetch active blocks for any date, supporting schedule visualization
Output: TimeBlockService with recurrence logic, date endpoint, and DailyNote integration
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-backend-foundation/01-RESEARCH.md

# Pattern reference for recurrence logic
@backend/src/Service/RecurringSyncService.php

# From previous plans
@backend/src/Entity/TimeBlock.php
@backend/src/Repository/TimeBlockRepository.php
@backend/src/Controller/TimeBlockController.php

# For DailyNote integration
@backend/src/Facade/BrainDumpFacade.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TimeBlockService</name>
  <files>
    backend/src/Service/TimeBlockService.php
  </files>
  <action>
Create TimeBlockService following RecurringSyncService pattern for recurrence logic:

```php
<?php

declare(strict_types=1);

namespace App\Service;

use App\Entity\TimeBlock;
use App\Entity\User;
use App\Enum\RecurrenceType;
use App\Repository\TimeBlockRepository;

class TimeBlockService
{
    public function __construct(
        private readonly TimeBlockRepository $timeBlockRepository,
    ) {
    }

    /**
     * Get all active time blocks for a user that are active on the given date.
     *
     * @return TimeBlock[]
     */
    public function getActiveBlocksForDate(User $user, \DateTimeInterface $date): array
    {
        $allBlocks = $this->timeBlockRepository->findActiveByUser($user);
        $activeBlocks = [];

        foreach ($allBlocks as $block) {
            if ($this->isActiveOnDate($block, $date)) {
                $activeBlocks[] = $block;
            }
        }

        // Sort by startTime
        usort($activeBlocks, fn (TimeBlock $a, TimeBlock $b) =>
            $a->getStartTime() <=> $b->getStartTime()
        );

        return $activeBlocks;
    }

    /**
     * Check if a time block should be active on the given date.
     */
    public function isActiveOnDate(TimeBlock $block, \DateTimeInterface $date): bool
    {
        $dayOfWeek = (int) $date->format('w'); // 0 = Sunday, 6 = Saturday

        return match ($block->getRecurrenceType()) {
            RecurrenceType::DAILY => true,
            RecurrenceType::WEEKLY => $this->matchesWeeklyPattern($block, $date),
            RecurrenceType::WEEKDAYS => $dayOfWeek >= 1 && $dayOfWeek <= 5,
            RecurrenceType::MONTHLY => $this->matchesMonthlyPattern($block, $date),
            RecurrenceType::CUSTOM => $this->matchesCustomPattern($block, $dayOfWeek),
        };
    }

    private function matchesWeeklyPattern(TimeBlock $block, \DateTimeInterface $date): bool
    {
        // Same day of week as creation date
        $createdDayOfWeek = (int) $block->getCreatedAt()->format('w');
        $targetDayOfWeek = (int) $date->format('w');
        return $createdDayOfWeek === $targetDayOfWeek;
    }

    private function matchesMonthlyPattern(TimeBlock $block, \DateTimeInterface $date): bool
    {
        // Same day of month as creation date
        $createdDayOfMonth = (int) $block->getCreatedAt()->format('j');
        $targetDayOfMonth = (int) $date->format('j');
        return $createdDayOfMonth === $targetDayOfMonth;
    }

    private function matchesCustomPattern(TimeBlock $block, int $dayOfWeek): bool
    {
        $recurrenceDays = $block->getRecurrenceDays() ?? [];
        return in_array($dayOfWeek, $recurrenceDays, true);
    }
}
```

**Recurrence logic matches RecurringSyncService exactly:**
- DAILY: Always active
- WEEKLY: Same weekday as creation date
- WEEKDAYS: Monday (1) through Friday (5)
- MONTHLY: Same day of month as creation date
- CUSTOM: dayOfWeek in recurrenceDays array (0=Sun, 1=Mon, ..., 6=Sat)
  </action>
  <verify>
Run: `docker compose exec php bin/console lint:container`
Verify TimeBlockService is autowirable
  </verify>
  <done>
TimeBlockService exists with getActiveBlocksForDate and isActiveOnDate methods.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Date Endpoint to Controller</name>
  <files>
    backend/src/Controller/TimeBlockController.php
  </files>
  <action>
Add date-specific endpoint to TimeBlockController:

1. **Inject TimeBlockService in constructor:**
```php
public function __construct(
    private readonly TimeBlockRepository $timeBlockRepository,
    private readonly TagRepository $tagRepository,
    private readonly TimeBlockService $timeBlockService,
    private readonly EntityManagerInterface $entityManager,
) {
}
```

2. **Add endpoint:**
```php
#[Route('/date/{date}', name: 'time_block_for_date', methods: ['GET'])]
public function getForDate(#[CurrentUser] User $user, string $date): JsonResponse
{
    try {
        $dateTime = new \DateTime($date);
    } catch (\Exception) {
        return $this->json([
            'error' => 'Invalid date format. Use YYYY-MM-DD.',
        ], Response::HTTP_BAD_REQUEST);
    }

    $blocks = $this->timeBlockService->getActiveBlocksForDate($user, $dateTime);

    return $this->json(array_map(
        fn (TimeBlock $tb) => $this->serializeTimeBlock($tb),
        $blocks
    ));
}
```

**Important:** Place this route BEFORE the `/{id}` routes in the controller file to avoid route matching issues. Symfony matches routes in order, and `date/{date}` would match `{id}` if `{id}` comes first.

Actually, better to use a different route pattern. Change to:
```php
#[Route('/for-date/{date}', name: 'time_block_for_date', methods: ['GET'])]
```
This avoids any ambiguity with the `/{id}` route.
  </action>
  <verify>
Run: `docker compose exec php bin/console debug:router | grep time-block`
Should show time_block_for_date route
  </verify>
  <done>
GET /api/time-block/for-date/{date} endpoint exists and returns filtered blocks.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate TimeBlocks into DailyNote Response</name>
  <files>
    backend/src/Facade/BrainDumpFacade.php
  </files>
  <action>
Add timeBlocks to DailyNote API response (REQ-008):

1. **Inject TimeBlockService in constructor:**
Add to existing constructor parameters:
```php
private readonly TimeBlockService $timeBlockService,
```

2. **Update getDailyNoteData method:**
In the getDailyNoteData method, add timeBlocks to the response.

Find the return statement that returns the array with 'tasks', 'events', 'notes', etc.

Add before the return:
```php
// Get active time blocks for this date
$timeBlocks = $this->timeBlockService->getActiveBlocksForDate($user, $date);
$serializedTimeBlocks = array_map(fn ($tb) => [
    'id' => $tb->getId(),
    'name' => $tb->getName(),
    'color' => $tb->getColor(),
    'startTime' => $tb->getStartTime()?->format('H:i'),
    'endTime' => $tb->getEndTime()?->format('H:i'),
    'tags' => array_map(fn ($tag) => [
        'id' => $tag->getId(),
        'name' => $tag->getName(),
        'color' => $tag->getColor(),
    ], $tb->getTags()->toArray()),
], $timeBlocks);
```

3. **Add to both return statements:**

In the early return (when $dailyNote is null but scheduled tasks exist):
```php
return [
    'id' => null,
    'date' => $date->format('Y-m-d'),
    'rawContent' => null,
    'tasks' => $tasks,
    'events' => [],
    'notes' => [],
    'journal' => [],
    'schedule' => [],
    'timeBlocks' => $serializedTimeBlocks,  // ADD THIS
    'createdAt' => null,
    'updatedAt' => null,
];
```

In the main return (when $dailyNote exists):
```php
'timeBlocks' => $serializedTimeBlocks,  // ADD THIS to the return array
```

**Import at top of file:**
```php
use App\Service\TimeBlockService;
```
  </action>
  <verify>
Run: `docker compose exec php bin/console lint:container`
Verify BrainDumpFacade is still valid
  </verify>
  <done>
DailyNote API response includes timeBlocks array for the requested date.
  </done>
</task>

</tasks>

<verification>
1. Container lint: `docker compose exec php bin/console lint:container`
2. Routes check: `docker compose exec php bin/console debug:router | grep time-block`
3. Service exists: `docker compose exec php bin/console debug:container TimeBlockService`
</verification>

<success_criteria>
- TimeBlockService exists with getActiveBlocksForDate method
- Recurrence logic correctly filters blocks by date
- GET /api/time-block/for-date/{date} returns active blocks for that date
- DailyNote response includes timeBlocks array
- All recurrence types work: daily, weekly, weekdays, monthly, custom
</success_criteria>

<output>
After completion, create `.planning/phases/01-backend-foundation/01-03-SUMMARY.md`
</output>
