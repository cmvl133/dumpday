---
phase: 01-backend-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/Entity/TimeBlock.php
  - backend/src/Entity/Tag.php
  - backend/src/Repository/TimeBlockRepository.php
  - backend/migrations/VersionXXXXXXXXXXXXXX.php
autonomous: true

must_haves:
  truths:
    - "TimeBlock entity can be persisted to database"
    - "TimeBlock has required fields: name, color, startTime, endTime, recurrenceType"
    - "TimeBlock belongs to User via ManyToOne"
    - "TimeBlock has ManyToMany relationship with Tag"
    - "Tag entity has inverse timeBlocks collection"
  artifacts:
    - path: "backend/src/Entity/TimeBlock.php"
      provides: "TimeBlock entity with Doctrine ORM mapping"
      exports: ["TimeBlock"]
      min_lines: 150
    - path: "backend/src/Repository/TimeBlockRepository.php"
      provides: "TimeBlockRepository extending ServiceEntityRepository"
      exports: ["TimeBlockRepository", "findActiveByUser"]
      min_lines: 30
    - path: "backend/src/Entity/Tag.php"
      provides: "Tag entity with timeBlocks inverse relationship"
      contains: "timeBlocks"
  key_links:
    - from: "backend/src/Entity/TimeBlock.php"
      to: "backend/src/Entity/User.php"
      via: "ManyToOne relationship"
      pattern: "ManyToOne.*User"
    - from: "backend/src/Entity/TimeBlock.php"
      to: "backend/src/Entity/Tag.php"
      via: "ManyToMany relationship"
      pattern: "ManyToMany.*Tag"
    - from: "backend/src/Entity/Tag.php"
      to: "backend/src/Entity/TimeBlock.php"
      via: "inverse ManyToMany"
      pattern: "mappedBy.*tags"
---

<objective>
Create TimeBlock entity and repository following established RecurringTask patterns

Purpose: Establish the data layer for time blocks - the foundation all other phase work builds on
Output: TimeBlock entity with Doctrine mapping, Tag inverse relationship, repository with query methods, applied migration
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-backend-foundation/01-RESEARCH.md

# Pattern references
@backend/src/Entity/RecurringTask.php
@backend/src/Entity/Tag.php
@backend/src/Entity/Task.php
@backend/src/Repository/RecurringTaskRepository.php
@backend/src/Enum/RecurrenceType.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TimeBlock Entity</name>
  <files>
    backend/src/Entity/TimeBlock.php
  </files>
  <action>
Create TimeBlock entity following RecurringTask pattern with these fields:

**Required fields:**
- `id` (int, auto-generated)
- `user` (ManyToOne to User, nullable: false, onDelete: CASCADE)
- `name` (string, length: 100)
- `color` (string, length: 7 - hex color)
- `startTime` (Types::TIME_MUTABLE)
- `endTime` (Types::TIME_MUTABLE)
- `recurrenceType` (RecurrenceType enum, default: DAILY)
- `recurrenceDays` (Types::JSON, nullable: true - for CUSTOM recurrence)
- `isActive` (boolean, default: true)
- `createdAt` (DateTimeImmutable, set via PrePersist)

**ManyToMany with Tag:**
- TimeBlock is owning side (inversedBy: 'timeBlocks')
- JoinTable name: 'time_block_tags'

**Use attributes (not annotations):**
```php
#[ORM\Entity(repositoryClass: TimeBlockRepository::class)]
#[ORM\Table(name: 'time_blocks')]
#[ORM\HasLifecycleCallbacks]
```

**Include:**
- Constructor initializing tags as ArrayCollection
- PrePersist lifecycle callback for createdAt
- All getters/setters with static return type for fluent interface
- addTag/removeTag methods matching Task entity pattern
  </action>
  <verify>
Run: `docker compose exec php bin/console lint:container`
Verify no syntax errors and entity is recognized
  </verify>
  <done>
TimeBlock.php exists with all fields, relationships, and lifecycle callbacks. Container lint passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Tag Inverse Relationship</name>
  <files>
    backend/src/Entity/Tag.php
  </files>
  <action>
Add inverse side of ManyToMany relationship to Tag entity:

1. Add property:
```php
/**
 * @var Collection<int, TimeBlock>
 */
#[ORM\ManyToMany(targetEntity: TimeBlock::class, mappedBy: 'tags')]
private Collection $timeBlocks;
```

2. Initialize in constructor (append to existing):
```php
$this->timeBlocks = new ArrayCollection();
```

3. Add getter:
```php
/**
 * @return Collection<int, TimeBlock>
 */
public function getTimeBlocks(): Collection
{
    return $this->timeBlocks;
}
```

4. Add addTimeBlock/removeTimeBlock methods following existing addTask/removeTask pattern

**Import TimeBlock at top of file.**
  </action>
  <verify>
Run: `docker compose exec php bin/console lint:container`
Verify Tag entity still valid with new relationship
  </verify>
  <done>
Tag.php has timeBlocks collection with getter and add/remove methods. Container lint passes.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create TimeBlockRepository</name>
  <files>
    backend/src/Repository/TimeBlockRepository.php
  </files>
  <action>
Create TimeBlockRepository following RecurringTaskRepository pattern:

```php
<?php

declare(strict_types=1);

namespace App\Repository;

use App\Entity\TimeBlock;
use App\Entity\User;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\Persistence\ManagerRegistry;

/**
 * @extends ServiceEntityRepository<TimeBlock>
 */
class TimeBlockRepository extends ServiceEntityRepository
{
    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, TimeBlock::class);
    }

    /**
     * Find all active time blocks for a given user.
     *
     * @return TimeBlock[]
     */
    public function findActiveByUser(User $user): array
    {
        return $this->createQueryBuilder('tb')
            ->where('tb.user = :user')
            ->andWhere('tb.isActive = true')
            ->setParameter('user', $user)
            ->orderBy('tb.startTime', 'ASC')
            ->getQuery()
            ->getResult();
    }
}
```
  </action>
  <verify>
Run: `docker compose exec php bin/console lint:container`
Verify repository is autowirable
  </verify>
  <done>
TimeBlockRepository.php exists with findActiveByUser method. Container lint passes.
  </done>
</task>

<task type="auto">
  <name>Task 4: Generate and Run Migration</name>
  <files>
    backend/migrations/VersionXXXXXXXXXXXXXX.php
  </files>
  <action>
Generate and apply database migration:

1. Generate migration:
```bash
docker compose exec php bin/console make:migration
```

2. Review generated migration - should create:
   - `time_blocks` table with all columns
   - `time_block_tags` join table
   - Foreign keys to users and tags

3. Apply migration:
```bash
docker compose exec php bin/console doctrine:migrations:migrate --no-interaction
```

**Expected table structure:**
- `time_blocks`: id, user_id, name, color, start_time, end_time, recurrence_type, recurrence_days, is_active, created_at
- `time_block_tags`: time_block_id, tag_id
  </action>
  <verify>
Run: `docker compose exec php bin/console doctrine:schema:validate`
Verify schema is in sync with entities
  </verify>
  <done>
Migration created and applied. Database has time_blocks and time_block_tags tables. Schema validation passes.
  </done>
</task>

</tasks>

<verification>
1. Container lint: `docker compose exec php bin/console lint:container`
2. Schema validation: `docker compose exec php bin/console doctrine:schema:validate`
3. Entity mapping: `docker compose exec php bin/console doctrine:mapping:info`
4. Check tables exist: `docker compose exec php bin/console dbal:run-sql "SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name LIKE 'time_block%'"`
</verification>

<success_criteria>
- TimeBlock entity exists with all required fields
- TimeBlock has ManyToOne to User with CASCADE delete
- TimeBlock has ManyToMany to Tag with join table
- Tag has inverse timeBlocks relationship
- TimeBlockRepository has findActiveByUser method
- Migration applied, database tables created
- Schema validation passes
</success_criteria>

<output>
After completion, create `.planning/phases/01-backend-foundation/01-01-SUMMARY.md`
</output>
