---
phase: 11-backend-tests
plan: 04
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - backend/tests/Unit/Service/PlanningServiceTest.php
autonomous: true
user_setup: []

must_haves:
  truths:
    - "PlanningService.getTasksForPlanning returns unplanned tasks, planned tasks, events, and blocks"
    - "PlanningService.updatePlanningFields uses PATCH semantics"
    - "PlanningService.acceptSchedule updates tasks from schedule items"
    - "PlanningService.acceptSchedule skips tasks not owned by user"
    - "PlanningService.acceptSchedule handles combinedWithEventId array"
  artifacts:
    - path: "backend/tests/Unit/Service/PlanningServiceTest.php"
      provides: "PlanningService unit tests with mocked dependencies"
      min_lines: 150
  key_links:
    - from: "backend/tests/Unit/Service/PlanningServiceTest.php"
      to: "backend/src/Service/PlanningService.php"
      via: "constructor injection"
      pattern: "new PlanningService"
    - from: "backend/tests/Unit/Service/PlanningServiceTest.php"
      to: "backend/src/Repository/TaskRepository.php"
      via: "createMock"
      pattern: "createMock\\(TaskRepository::class\\)"
---

<objective>
Create unit tests for PlanningService with mocked dependencies

Purpose: Verify PlanningService correctly orchestrates planning operations, task queries, and schedule acceptance without actual database.

Output: Comprehensive PlanningService test file covering getTasksForPlanning, updatePlanningFields, and acceptSchedule
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-backend-tests/11-RESEARCH.md

@backend/src/Service/PlanningService.php
@backend/src/Service/TimeBlockService.php
@backend/src/Service/TaskBlockMatchingService.php
@backend/src/Service/TaskEventConflictResolver.php
@backend/src/Entity/Task.php
@backend/src/Repository/TaskRepository.php
@backend/src/Repository/EventRepository.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: PlanningService getTasksForPlanning and updatePlanningFields tests</name>
  <files>backend/tests/Unit/Service/PlanningServiceTest.php</files>
  <action>
Create PlanningServiceTest with mocked dependencies.

1. Set up mocked dependencies:
```php
use PHPUnit\Framework\TestCase;
use PHPUnit\Framework\Attributes\Test;
use App\Service\PlanningService;
use App\Service\TimeBlockService;
use App\Service\TaskBlockMatchingService;
use App\Service\TaskEventConflictResolver;
use Doctrine\ORM\EntityManagerInterface;
use App\Repository\TaskRepository;
use App\Repository\EventRepository;

class PlanningServiceTest extends TestCase
{
    private PlanningService $service;
    private EntityManagerInterface $entityManager;
    private TaskRepository $taskRepository;
    private EventRepository $eventRepository;
    private TimeBlockService $timeBlockService;
    private TaskBlockMatchingService $taskBlockMatchingService;
    private TaskEventConflictResolver $conflictResolver;

    protected function setUp(): void
    {
        $this->entityManager = $this->createMock(EntityManagerInterface::class);
        $this->taskRepository = $this->createMock(TaskRepository::class);
        $this->eventRepository = $this->createMock(EventRepository::class);
        $this->timeBlockService = $this->createMock(TimeBlockService::class);
        $this->taskBlockMatchingService = $this->createMock(TaskBlockMatchingService::class);
        $this->conflictResolver = $this->createMock(TaskEventConflictResolver::class);

        $this->service = new PlanningService(
            $this->entityManager,
            $this->taskRepository,
            $this->eventRepository,
            $this->timeBlockService,
            $this->taskBlockMatchingService,
            $this->conflictResolver
        );
    }
}
```

2. Test getTasksForPlanning():
   - Calls all required repository/service methods
   - Returns array with correct keys: unplannedTasks, plannedTasks, events, activeBlocks, conflicts
```php
#[Test]
public function getTasksForPlanningReturnsAllPlanningData(): void
{
    $user = $this->createMock(User::class);
    $date = new \DateTime('2026-01-22');

    $unplannedTasks = [new Task(), new Task()];
    $plannedTasks = [new Task()];
    $events = [new Event()];
    $activeBlocks = [['id' => 1, 'name' => 'Morning']];
    $conflicts = [];

    $this->taskRepository
        ->expects($this->once())
        ->method('findUnplannedTasksForToday')
        ->with($user, $date)
        ->willReturn($unplannedTasks);

    $this->taskRepository
        ->expects($this->once())
        ->method('findPlannedTasksForToday')
        ->with($user, $date)
        ->willReturn($plannedTasks);

    $this->eventRepository
        ->expects($this->once())
        ->method('findByUserAndDate')
        ->with($user, $date)
        ->willReturn($events);

    $this->timeBlockService
        ->expects($this->once())
        ->method('getActiveBlocksForDate')
        ->with($user, $date)
        ->willReturn($activeBlocks);

    $this->conflictResolver
        ->expects($this->once())
        ->method('findConflictingTasks')
        ->with($plannedTasks, $events)
        ->willReturn($conflicts);

    $result = $this->service->getTasksForPlanning($user, $date);

    $this->assertArrayHasKey('unplannedTasks', $result);
    $this->assertArrayHasKey('plannedTasks', $result);
    $this->assertArrayHasKey('events', $result);
    $this->assertArrayHasKey('activeBlocks', $result);
    $this->assertArrayHasKey('conflicts', $result);
    $this->assertSame($unplannedTasks, $result['unplannedTasks']);
}
```

3. Test updatePlanningFields() with PATCH semantics:
   - Only updates provided fields
   - Explicit null clears field
   - Handles estimatedMinutes, fixedTime, canCombineWithEvents, needsFullFocus
```php
#[Test]
public function updatePlanningFieldsOnlyChangesProvidedFields(): void
{
    $task = new Task();
    $task->setEstimatedMinutes(30);
    $task->setNeedsFullFocus(true);

    // Only provide estimatedMinutes, not needsFullFocus
    $data = ['estimatedMinutes' => 60];
    $result = $this->service->updatePlanningFields($task, $data);

    $this->assertSame(60, $result->getEstimatedMinutes());
    $this->assertTrue($result->getNeedsFullFocus()); // Unchanged
}

#[Test]
public function updatePlanningFieldsSetsFixedTimeFromString(): void
{
    $task = new Task();

    $data = ['fixedTime' => '09:30'];
    $result = $this->service->updatePlanningFields($task, $data);

    $this->assertNotNull($result->getFixedTime());
    $this->assertSame('09:30', $result->getFixedTime()->format('H:i'));
}

#[Test]
public function updatePlanningFieldsClearsFixedTimeWhenNull(): void
{
    $task = new Task();
    $task->setFixedTime(new \DateTimeImmutable('09:30'));

    $data = ['fixedTime' => null];
    $result = $this->service->updatePlanningFields($task, $data);

    $this->assertNull($result->getFixedTime());
}
```
  </action>
  <verify>
Run: `docker compose exec php ./vendor/bin/phpunit tests/Unit/Service/PlanningServiceTest.php --filter="getTasksForPlanning|updatePlanningFields"`
Tests pass.
  </verify>
  <done>
getTasksForPlanning tested for correct data assembly. updatePlanningFields tested for PATCH semantics with all planning fields.
  </done>
</task>

<task type="auto">
  <name>Task 2: PlanningService acceptSchedule tests</name>
  <files>backend/tests/Unit/Service/PlanningServiceTest.php</files>
  <action>
Add tests for acceptSchedule() to PlanningServiceTest.

1. Test acceptSchedule updates tasks from schedule items:
```php
#[Test]
public function acceptScheduleUpdatesTasksFromScheduleItems(): void
{
    $user = $this->createMock(User::class);
    $user->method('getId')->willReturn(1);

    $dailyNote = $this->createMock(DailyNote::class);
    $dailyNote->method('getUser')->willReturn($user);

    $task = new Task();
    $reflection = new \ReflectionClass($task);
    $prop = $reflection->getProperty('dailyNote');
    $prop->setAccessible(true);
    $prop->setValue($task, $dailyNote);

    $this->taskRepository
        ->method('find')
        ->with(1)
        ->willReturn($task);

    $this->entityManager
        ->expects($this->once())
        ->method('flush');

    $scheduleItems = [
        [
            'taskId' => 1,
            'suggestedTime' => '09:00',
            'duration' => 45,
        ],
    ];

    $this->service->acceptSchedule($user, $scheduleItems);

    $this->assertSame('09:00', $task->getFixedTime()->format('H:i'));
    $this->assertSame(45, $task->getEstimatedMinutes());
}
```

2. Test acceptSchedule skips tasks not owned by user:
```php
#[Test]
public function acceptScheduleSkipsOtherUsersTasks(): void
{
    $requestingUser = $this->createMock(User::class);
    $requestingUser->method('getId')->willReturn(1);

    $taskOwner = $this->createMock(User::class);
    $taskOwner->method('getId')->willReturn(2);

    $dailyNote = $this->createMock(DailyNote::class);
    $dailyNote->method('getUser')->willReturn($taskOwner);

    $task = new Task();
    $task->setEstimatedMinutes(30); // Original value
    $reflection = new \ReflectionClass($task);
    $prop = $reflection->getProperty('dailyNote');
    $prop->setAccessible(true);
    $prop->setValue($task, $dailyNote);

    $this->taskRepository
        ->method('find')
        ->willReturn($task);

    $scheduleItems = [
        ['taskId' => 1, 'duration' => 60],
    ];

    $this->service->acceptSchedule($requestingUser, $scheduleItems);

    // Task should not be modified
    $this->assertSame(30, $task->getEstimatedMinutes());
}
```

3. Test acceptSchedule handles combinedWithEventId:
```php
#[Test]
public function acceptScheduleAddsCombinedEventIdToArray(): void
{
    $user = $this->createMock(User::class);
    $user->method('getId')->willReturn(1);

    $dailyNote = $this->createMock(DailyNote::class);
    $dailyNote->method('getUser')->willReturn($user);

    $task = new Task();
    $task->setCanCombineWithEvents([5]); // Existing event ID
    $reflection = new \ReflectionClass($task);
    $prop = $reflection->getProperty('dailyNote');
    $prop->setAccessible(true);
    $prop->setValue($task, $dailyNote);

    $this->taskRepository->method('find')->willReturn($task);

    $scheduleItems = [
        ['taskId' => 1, 'combinedWithEventId' => 10],
    ];

    $this->service->acceptSchedule($user, $scheduleItems);

    $this->assertContains(5, $task->getCanCombineWithEvents());
    $this->assertContains(10, $task->getCanCombineWithEvents());
}

#[Test]
public function acceptScheduleDoesNotDuplicateCombinedEventId(): void
{
    $user = $this->createMock(User::class);
    $user->method('getId')->willReturn(1);

    $dailyNote = $this->createMock(DailyNote::class);
    $dailyNote->method('getUser')->willReturn($user);

    $task = new Task();
    $task->setCanCombineWithEvents([10]); // Already has the ID
    $reflection = new \ReflectionClass($task);
    $prop = $reflection->getProperty('dailyNote');
    $prop->setAccessible(true);
    $prop->setValue($task, $dailyNote);

    $this->taskRepository->method('find')->willReturn($task);

    $scheduleItems = [
        ['taskId' => 1, 'combinedWithEventId' => 10],
    ];

    $this->service->acceptSchedule($user, $scheduleItems);

    $this->assertCount(1, $task->getCanCombineWithEvents()); // Still just one
}
```

4. Test acceptSchedule updates overdue task dueDate:
```php
#[Test]
public function acceptScheduleUpdatesOverdueDueDateToToday(): void
{
    $user = $this->createMock(User::class);
    $user->method('getId')->willReturn(1);

    $dailyNote = $this->createMock(DailyNote::class);
    $dailyNote->method('getUser')->willReturn($user);

    $task = new Task();
    $task->setDueDate(new \DateTime('-1 week')); // Overdue
    $reflection = new \ReflectionClass($task);
    $prop = $reflection->getProperty('dailyNote');
    $prop->setAccessible(true);
    $prop->setValue($task, $dailyNote);

    $this->taskRepository->method('find')->willReturn($task);

    $scheduleItems = [
        ['taskId' => 1, 'suggestedTime' => '10:00'],
    ];

    $this->service->acceptSchedule($user, $scheduleItems);

    $this->assertSame(
        (new \DateTime('today'))->format('Y-m-d'),
        $task->getDueDate()->format('Y-m-d')
    );
}
```

5. Test acceptSchedule skips non-existent tasks:
```php
#[Test]
public function acceptScheduleSkipsNonExistentTasks(): void
{
    $user = $this->createMock(User::class);

    $this->taskRepository
        ->method('find')
        ->with(999)
        ->willReturn(null);

    // Should not throw, just skip
    $this->entityManager
        ->expects($this->once())
        ->method('flush');

    $scheduleItems = [
        ['taskId' => 999, 'suggestedTime' => '10:00'],
    ];

    $this->service->acceptSchedule($user, $scheduleItems);
}
```
  </action>
  <verify>
Run: `docker compose exec php ./vendor/bin/phpunit tests/Unit/Service/PlanningServiceTest.php`
All tests pass.
  </verify>
  <done>
PlanningService fully tested: getTasksForPlanning returns all planning data, updatePlanningFields uses PATCH semantics, acceptSchedule handles task updates, user ownership, combinedWithEventId arrays, and overdue dates.
  </done>
</task>

</tasks>

<verification>
Run full PlanningService test suite:
```bash
docker compose exec php ./vendor/bin/phpunit tests/Unit/Service/PlanningServiceTest.php --testdox
```

Expected: All tests pass, demonstrating service logic works correctly with mocked dependencies.
</verification>

<success_criteria>
1. PlanningServiceTest.php exists with comprehensive test coverage
2. All dependencies properly mocked (EntityManager, repositories, services)
3. getTasksForPlanning tested for correct data assembly
4. updatePlanningFields PATCH semantics verified
5. acceptSchedule tested for: task updates, user ownership checks, combinedWithEventId handling, overdue date updates
6. All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-backend-tests/11-04-SUMMARY.md`
</output>
